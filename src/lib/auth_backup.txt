/**
 * Biblioteca de AutenticaÃ§Ã£o JWT
 * 
 * Gerencia autenticaÃ§Ã£o baseada em JWT para o sistema MeuDashboard.
 * 
 * Funcionalidades:
 * - CriaÃ§Ã£o e verificaÃ§Ã£o de tokens JWT
 * - Gerenciamento de cookies de autenticaÃ§Ã£o
 * - ValidaÃ§Ã£o de usuÃ¡rios autenticados
 * - IntegraÃ§Ã£o com Supabase para validaÃ§Ã£o de usuÃ¡rios
 */

import { SignJWT, jwtVerify } from 'jose';
import { cookies } from 'next/headers';
import { supabase } from './supabase';
import type { AuthUser, JWTPayload } from '@/types';

/**
 * Retorna a chave secreta JWT codificada
 */
function getJwtSecret(): Uint8Array {
  const secret = process.env.JWT_SECRET;
  if (!secret) {
    throw new Error('JWT_SECRET nÃ£o configurado');
  }
  return new TextEncoder().encode(secret);
}

/**
 * Cria um token JWT com o payload fornecido
 * @param payload - Dados do usuÃ¡rio para incluir no token
 * @returns Token JWT assinado
 */
export async function createToken(payload: JWTPayload): Promise<string> {
  try {
    const secret = getJwtSecret();
    const token = await new SignJWT(payload as any)
      .setProtectedHeader({ alg: 'HS256' })
      .setExpirationTime('7d')
      .sign(secret);
    
    return token;
  } catch (error) {
    throw new Error('Erro ao criar token JWT');
  }
}

/**
 * Verifica e decodifica um token JWT
 * @param token - Token JWT a ser verificado
 * @returns Payload decodificado ou null se invÃ¡lido
 */
export async function verifyToken(token: string): Promise<JWTPayload | null> {
  try {
    const secret = getJwtSecret();
    const { payload } = await jwtVerify(token, secret);
    return payload as unknown as JWTPayload;
  } catch (error) {
    return null;
  }
}

/**
 * Define o cookie de autenticaÃ§Ã£o
 * @param token - Token JWT a ser armazenado
 */
export async function setAuthCookie(token: string): Promise<void> {
  try {
    const cookieStore = await cookies();
    const isProduction = process.env.NODE_ENV === 'production';

    // Em produÃ§Ã£o, define o domain para funcionar com e sem www
    const cookieOptions: {
      httpOnly: boolean;
      secure: boolean;
      sameSite: 'lax' | 'strict' | 'none';
      maxAge: number;
      path: string;
      domain?: string;
    } = {
      httpOnly: true,
      secure: isProduction,
      sameSite: 'lax',
      maxAge: 60 * 60 * 24 * 7, // 7 dias em segundos
      path: '/',
    };

    // Adiciona domain em produÃ§Ã£o para funcionar em www e sem www
    if (isProduction) {
      cookieOptions.domain = '.meudashboard.org'; // O ponto permite subdomÃ­nios
    }

    cookieStore.set('auth_token', token, cookieOptions);
  } catch (error) {
    throw new Error('Erro ao definir cookie de autenticaÃ§Ã£o');
  }
}

/**
 * Remove o cookie de autenticaÃ§Ã£o
 */
export async function removeAuthCookie(): Promise<void> {
  try {
    const cookieStore = await cookies();
    cookieStore.delete('auth_token');
  } catch (error) {
    throw new Error('Erro ao remover cookie de autenticaÃ§Ã£o');
  }
}

/**
 * ObtÃ©m o usuÃ¡rio autenticado a partir do cookie
 * @returns UsuÃ¡rio autenticado ou null se nÃ£o autenticado/invÃ¡lido
 */
export async function getAuthUser(): Promise<AuthUser | null> {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('auth_token')?.value;

    if (!token) {
      return null;
    }

    const payload = await verifyToken(token);
    if (!payload) {
      return null;
    }

    // Extrai o session_id do payload junto com o id
    const sessionId = payload.session_id;
    const userId = payload.id;

    // Busca o usuÃ¡rio no Supabase (incluindo current_session_id)
    const { data: user, error } = await supabase
      .from('users')
      .select('id, email, full_name, is_master, status, avatar_url, current_session_id')
      .eq('id', userId)
      .single();

    if (error || !user) {
      return null;
    }

    // Verifica se a sessÃ£o ainda Ã© vÃ¡lida (login Ãºnico)
    // Se current_session_id do banco for diferente do session_id do token,
    // significa que outra sessÃ£o foi iniciada e esta foi invalidada
    if (user.current_session_id !== sessionId) {
      return null;
    }

    // Verifica se o usuÃ¡rio nÃ£o estÃ¡ suspenso
    if (user.status === 'suspended') {
      return null;
    }

    // Retorna o usuÃ¡rio no formato AuthUser
    return {
      id: user.id,
      email: user.email,
      full_name: user.full_name || '',
      is_master: user.is_master || false,
      status: user.status,
      avatar_url: user.avatar_url || undefined,
    } as AuthUser;
  } catch (error) {
    return null;
  }
}


/**
 * Verifica se o usuário é um desenvolvedor
 */
export async function getUserDeveloperId(userId: string): Promise<string | null> {
  try {
    const { data, error } = await supabase
      .from('developer_users')
      .select('developer_id')
      .eq('user_id', userId)
      .eq('is_active', true)
      .limit(1)
      .maybeSingle();

    if (error || !data) {
      return null;
    }

    return data.developer_id;
  } catch (error) {
    return null;
  }
}

/**
 * Obtém usuário com info de desenvolvedor
 */
export async function getAuthUserWithDeveloper(): Promise<(AuthUser & { developer_id?: string; developer_role?: string }) | null> {
  try {
    const user = await getAuthUser();
    if (!user) return null;

    const { data: devUser } = await supabase
      .from('developer_users')
      .select('developer_id, role')
      .eq('user_id', user.id)
      .eq('is_active', true)
      .limit(1)
      .maybeSingle();

    return {
      ...user,
      developer_id: devUser?.developer_id || undefined,
      developer_role: devUser?.role || undefined,
    };
  } catch (error) {
    return null;
  }
}
